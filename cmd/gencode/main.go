package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"golang.org/x/tools/go/packages"
)

func main() {
	modRoot := moduleRoot()
	modName := readModuleName(modRoot)
	cfg := &packages.Config{
		Dir:  modRoot,
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax,
	}
	pkgs, err := packages.Load(cfg, "./internal/selector/...")
	if err != nil {
		panic(err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	var imports []string
	for _, p := range pkgs {
		// パッケージ向けソース生成
		isWrote, err := generateRegisterFile(p, modName)
		if err != nil {
			panic(err)
		}
		if isWrote {
			// 生成したファイルは autoload/packages_gen.go 用のインポートに追加
			imports = append(imports, p.PkgPath)
		}
	}
	// 出力内容を安定させるためソート
	slices.Sort(imports)
	imports = slices.Compact(imports)

	// autoload 用ファイル生成
	if err := generateAutoloadFile(imports, modRoot); err != nil {
		panic(err)
	}
}

// generateRegisterFile は個々のパッケージ向けに register_gen.go を生成して書き出します。
func generateRegisterFile(p *packages.Package, modName string) (bool, error) {
	if len(p.GoFiles) == 0 {
		return false, nil
	}
	// 対象ディレクトリ
	dir := filepath.Dir(p.GoFiles[0])
	// シンタックスツリーから必要な情報を収集
	sels := pickSelectorVars(p)
	// Selectors 部分を組み立て
	selectorsStr := strings.Builder{}
	if len(sels) == 0 {
		return false, nil // Selectorが無ければ生成不要
	} else {
		selectorsStr.WriteString("[]common.SelectorGroup{\n")
		for _, s := range sels {
			fmt.Fprintf(&selectorsStr, "%s,\n", s)
		}
		selectorsStr.WriteString("}")
	}
	// 各パッケージにソース生成 (register_gen.go)
	var out bytes.Buffer
	template := fmt.Sprintf(`// Code generated by cmd/gencode; DO NOT EDIT.
package %s

import (
    %q
	%q
)

func init() {
	registry.Register(%s)
}
`,
		p.Name,
		modName+"/internal/selector/registry",
		modName+"/internal/selector/common",
		selectorsStr.String())
	out.WriteString(template)

	src, err := format.Source(out.Bytes())
	if err != nil {
		// フォーマットエラーはそのまま書き出す
		src = out.Bytes()
	}

	dst := filepath.Join(dir, "register_gen.go")
	if err := os.WriteFile(dst, src, 0o644); err != nil {
		return false, err
	}
	fmt.Println("wrote", dst)
	return true, nil
}

func pickSelectorVars(p *packages.Package) []string {
	if len(p.Syntax) == 0 {
		return nil
	}
	sels := make([]string, 0, 10)
	for _, f := range p.Syntax {
		ast.Inspect(f, func(n ast.Node) bool {
			decl, ok := n.(*ast.GenDecl)
			// var宣言以外はスキップ
			if !ok || decl.Tok != token.VAR {
				return true
			}
			for _, spec := range decl.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok {
					continue
				}
				for i, name := range vs.Names {
					if i < len(vs.Values) && vs.Values[i] != nil {
						// CompositeLit (構造体リテラル) の場合のみ対象とする
						if compLit, ok := vs.Values[i].(*ast.CompositeLit); ok {
							// 型名を確認し、common.SelectorGroup なら登録対象とする
							typeName := getTypeName(compLit.Type)
							if typeName == "common.SelectorGroup" {
								sels = append(sels, name.Name)
							}
						}
					}
				}
			}
			return false
		})
	}
	return sels
}

// generateAutoloadFile は autoload/packages_gen.go を生成して書き出します。
func generateAutoloadFile(imports []string, modRoot string) error {
	var out bytes.Buffer
	// import対象
	importsStr := strings.Builder{}
	for _, imp := range imports {
		// %qを利用したいのでFprintfで書き出す
		fmt.Fprintf(&importsStr, "    _ %q\n", imp)
	}

	template := fmt.Sprintf(`// Code generated by cmd/gen-infocode; DO NOT EDIT.
package autoload

import (
%s
)
`, importsStr.String())
	out.WriteString(template)

	src, err := format.Source(out.Bytes())
	if err != nil {
		// フォーマットに失敗しても一旦そのまま書き出す
		src = out.Bytes()
	}

	dst := filepath.Join(modRoot, "internal", "selector", "autoload", "packages_gen.go")
	if err := os.WriteFile(dst, src, 0o644); err != nil {
		return err
	}
	fmt.Println("wrote", dst)
	return nil
}

func moduleRoot() string {
	dir, _ := os.Getwd()
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			panic("go.mod not found")
		}
		dir = parent
	}
}

func readModuleName(modRoot string) string {
	f, err := os.Open(filepath.Join(modRoot, "go.mod"))
	if err != nil {
		panic(err)
	}
	defer f.Close()

	sc := bufio.NewScanner(f)
	for sc.Scan() {
		line := strings.TrimSpace(sc.Text())
		if strings.HasPrefix(line, "module ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				return parts[1]
			}
		}
	}
	if err := sc.Err(); err != nil {
		panic(err)
	}
	panic("module name not found in go.mod")
}

func getTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return getTypeName(t.X) + "." + t.Sel.Name
	default:
		return "unknown"
	}
}
